enum EnemyState { Idle, Aware, Aggroed, Stunned, Distracted }

class EnemyAI : ZilchComponent
{
    [Dependency] 
    var NavigationEvents : NavigationEvents = null;
    [Property]
    var AttackDamage : Integer = 50;
    var CurrentTile : Cog = null;
    var Disabled : Boolean = true;
    var TargetTile : Cog = null;
    var ToTargetVector : Real3 = Real3(0, 0, 0);
    var ToPlayerRay : Ray = Ray();
    var RayFilter : CastFilter = CastFilter();
    var State : EnemyState = EnemyState.Idle;
    var Player : Cog = null;
    var PlayerSightCooldown : Real = 0.0;
    var SeesPlayer : Boolean = false;
    var LevelGeometry : Cog = null;
    var DistractingLocation : Real3 = Real3(0, 0, 0);
    var StunTime : Real = 0.0;
    [Property]
    var MaxStunTime : Real = 2.5; //The amount of time the enemy will be stunned for
    [Property]
    var Speed : Real = 1.0; //Movement speed
    [Property]
    var SightDistance : Real = 5.0; //Minimum sight distance for becoming aggroed
    [Property]
    var AttentionSpanTime : Real = 3.0; //Max amount of time it takes to lose interest and become idle
    [Property]
    var AttackCooldown : Real = 0.3; //The cooldown between attacks for the enemy
    [Dependency]
    var Soundbox : Soundbox_Keres = null;
    var FootstepCounter : Real = 0.0;
    var BangTimeCooldown : Real = 0.0;
    var CurrentCooldown : Real = 0.0;
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.Space, "PathingChanged", this.UpdateTilePath);
        Zero.Connect(this.Space, "ReadyToPlay", this.Enable);
        Zero.Connect(this.Owner, Events.CollisionStarted, this.StartCollide);
        Zero.Connect(this.Owner, Events.CollisionPersisted, this.AttackPlayer);
        this.Player = this.Owner.Space.FindObjectByName("Player");
        this.LevelGeometry = this.Owner.Space.FindObjectByName("LevelGeometry");
        this.RayFilter.CollisionGroup = CollisionGroup.Find("LineofSightRayGroup");
    }
    
    //Enables the enemy once the map has been generated
    function Enable(event : ReadyEvent)
    {
        this.Disabled = false;
    }
    
    //Attempts to distract the enemy, won't work if they have direct line-of-sight to the player
    function Distract(locationOfDistraction : Real3)
    {
        if (!this.SeesPlayer)
        {
            this.State = EnemyState.Distracted;
            this.DistractingLocation = locationOfDistraction;
        }
    }
    
    function StartCollide(event : CollisionEvent)
    {
        if (event.OtherObject.Name == "Player" && this.CurrentCooldown <= 0.0 && this.State != EnemyState.Stunned)
        {
            event.OtherObject.PlayerStats.Life -= this.AttackDamage;
            this.CurrentCooldown = this.AttackCooldown;
            event.OtherObject.Soundbox_Player.PlayHit();
            Console.WriteLine("Attacked");
        }
        else if (event.OtherObject.GatePiece != null && this.BangTimeCooldown <= 0.0)
        {
            this.Owner.Soundbox_Keres.PlayDoorBang();
            this.BangTimeCooldown = 0.6;
            Console.WriteLine("Doorbang");
        }
    }
    
    //Attacks the player upon collision
    function AttackPlayer(event : CollisionEvent)
    {
        if (event.OtherObject.Name == "Player" && this.CurrentCooldown <= 0.0 && this.State != EnemyState.Stunned)
        {
            event.OtherObject.PlayerStats.Life -= this.AttackDamage;
            this.CurrentCooldown = this.AttackCooldown;
            event.OtherObject.Soundbox_Player.PlayHit();
            Console.WriteLine("Attacked");
        }
    }

    //Updates the enemy
    function OnLogicUpdate(event : UpdateEvent)
    {
        if (!this.Disabled)
        {
            //Decreases the attack cooldown if the enemy recently attacked
            if (this.CurrentCooldown > 0.0)
            {
                this.CurrentCooldown -= event.Dt;
            }
            
            if (this.BangTimeCooldown > 0.0)
            {
                this.BangTimeCooldown -= event.Dt;
            }
            
            //If the enemy's state is Aware or Distracted, it moves along the grid and checks for line-of-sight to the player
            if (this.State == EnemyState.Aware || this.State == EnemyState.Distracted)
            {
                //Console.WriteLine("Aware");
                this.MoveByGrid(event.Dt);
                this.CheckForPlayer(event.Dt);
                if (this.FootstepCounter <= 0.0)
                {
                    this.FootstepCounter = 1.4;
                    this.Soundbox.PlayFootstep();
                }
            }
            //If the enemy is aggroed, it moves directly towards the player and checks for line-of-sight to the player
            //If line-of-sight is lost, then the player is behind a wall or something, so it reverts back to the grid-based movement
            else if (this.State == EnemyState.Aggroed)
            {
                //Console.WriteLine("Aggoed");
                this.MoveTowardsPlayer(event.Dt);
                this.CheckForPlayer(event.Dt);
                if (this.FootstepCounter <= 0.0)
                {
                    this.FootstepCounter = 1.4;
                    this.Soundbox.PlayFootstep();
                }
            }
            //If the enemy is stunned, it doesn't do anything until the stun cooldown is over, at which point it returns to Aware
            else if (this.State == EnemyState.Stunned)
            {
                //Console.WriteLine("Stunned");
                this.BeStunned(event.Dt);
            }
            //Otherwise, the enemy is idle and doesn't do anything
            else
            {
                //Console.WriteLine("Idle");
                this.CheckForPlayer(event.Dt);
                if (this.CurrentTile != null)
                {
                    this.GetNextTile();
                }
                else
                {
                    this.GetCurrentTile();
                }
            }
        }
    }
    
    //Stuns the enemy, holding it in place for a period of time
    function Stun()
    {
        this.State = EnemyState.Stunned;
        this.StunTime = this.MaxStunTime;
        this.Owner.SoundEmitter.Stop();
        Console.WriteLine("Stunned");
        this.Owner.RigidBody.Static = true;
        this.Owner.RigidBody.Velocity *= 0;
    }
    
    //Does nothing for as long as the enemy is stunned
    function BeStunned(deltaTime : Real)
    {
        if (this.StunTime <= 0.0)
        {
            this.State = EnemyState.Aware;
            this.Owner.RigidBody.Static = false;
            this.GetCurrentTile();
            this.GetNextTile();
        }
        this.StunTime -= deltaTime;
    }
    
    //Wanders. Currently not implemented
    function Wander(deltaTime : Real)
    {
        
    }
    
    //Moves directly towards the player
    function MoveTowardsPlayer(deltaTime : Real)
    {
        this.Owner.RigidBody.Velocity = this.Speed * Math.Normalize(this.Player.Transform.Translation - this.Owner.Transform.Translation);
        this.FootstepCounter -= deltaTime;
    }
    
    //Moves along a grid towards the player
    function MoveByGrid(deltaTime : Real)
    {
        //If the enemy has a tile to move to
        if (this.TargetTile != null)
        {
            //Gets the distance from the enemy to the tile
            var temp = Math.Distance(this.Owner.Transform.Translation, this.TargetTile.Transform.WorldTranslation * Real3(1, 1, 0));
            
            //Sets the velocity to 0, necessary for certain situations that would otherwise make the
            //enemy run straight into a wall
            this.Owner.RigidBody.Velocity *= 0;
            
            //If the length is greater than the distance the enemy will move during this frame, set the enemy's velocity
            if (temp > 0.04)
            {
                this.Owner.RigidBody.Velocity = this.Speed * this.ToTargetVector;
            }
            //If the enemy is close enough to the next tile, set the current tile to the next tile and get the next tile from there
            else
            {
                this.CurrentTile = this.TargetTile;
                this.GetNextTile();
            }
        }
        //If the enemy doesn't have a tile to move to
        else
        {
            //Find the next tile to move to, oddly enough
            this.GetNextTile();
        }
        
        this.FootstepCounter -= deltaTime;
    }
    
    //Uses rayscanning to check for direct line-of-sight to the player, setting the enemy state as a result
    function CheckForPlayer(deltaTime : Real)
    {
        if (this.Owner.DebugEnemyState != null)
        {
            
        }
        else
        {
        //Initialize the ray to cast
        this.ToPlayerRay.Start = this.Owner.Transform.Translation;
        this.ToPlayerRay.Direction = Math.Normalize(this.Player.Transform.Translation - this.Owner.Transform.Translation);
        
        //Cast the ray
        var detectPlayer = this.Space.PhysicsSpace.CastRayFirstFiltered(this.ToPlayerRay, this.RayFilter);
        
        //If the player was hit by the ray
        if (detectPlayer.ObjectHit != null && detectPlayer.ObjectHit.Name == "Player")
        {
            this.SeesPlayer = true;
            
            //If the player is within sight distance, immediately begin aggroing and head straight towards him
            if (Math.Distance(this.Player.Transform.Translation, this.Owner.Transform.Translation) <= this.SightDistance)
            {
                if (this.State != EnemyState.Aggroed)
                {
                    this.State = EnemyState.Aggroed;
                    Console.WriteLine("Aggroed");
                    this.PlayerSightCooldown = this.AttentionSpanTime;
                }
            }
            //Otherwise, become aware of the player's presence and navigate towards his location
            else
            {
                if (this.State != EnemyState.Aware)
                {
                    this.State = EnemyState.Aware;
                    Console.WriteLine("Aware");
                    this.PlayerSightCooldown = this.AttentionSpanTime;
                    this.GetCurrentTile();
                    this.GetNextTile();
                }
            }
        }
        //If no line-of-sight is acquired, but the enemy is aggroed, then the player is behind something that the enemy
        //has to navigate around, so it becomes Aware and uses grid navigation instead of making a beeline
        else if (this.State == EnemyState.Aggroed)
        {
            if (this.State != EnemyState.Aware)
            {
                this.SeesPlayer = false;
                this.State = EnemyState.Aware;
                Console.WriteLine("Aware");
                this.PlayerSightCooldown = this.AttentionSpanTime;
                this.GetCurrentTile();
                this.GetNextTile();
            }
        }
        //If the player isn't hit by the ray, meaning that the enemy doesn't have direct line-of-sight
        else
        {
            if (this.State != EnemyState.Idle && this.State != EnemyState.Distracted)
            {
                this.SeesPlayer = false;
                //Counts down the attention span timer
                this.PlayerSightCooldown -= deltaTime;
                //If the player has been out of sight for the length of the enemy's attention span, the enemy resumes being idle
                if (this.PlayerSightCooldown <= 0.0)
                {
                    Console.WriteLine("Idle");
                    this.State = EnemyState.Idle;
                    this.Owner.RigidBody.Velocity *= 0;
                }
            }
        }
        }
    }
    
    //Changes the tile the enemy will moves to if the pathing grid is updates
    function UpdateTilePath(event : PathingUpdateEvent)
    {
        //this.GetNextTile();
    }
    
    //Gets the next tile to go to in the pathing grid
    function GetNextTile()
    {
        //Find the first tile of the lowest weight
        foreach (var ti in this.CurrentTile.NavigationPoint.NearPoints)
        {
            if (ti.NavigationPoint.Weight < this.CurrentTile.NavigationPoint.Weight)
            {
                this.TargetTile = ti;
            }
        }
        
        //If a tile was found (always gonna happen), set the movement vector towards it
        if (this.TargetTile != null)
        {
            this.ToTargetVector = Math.Normalize((this.TargetTile.Transform.WorldTranslation - this.Owner.Transform.Translation) * Real3(1, 1, 0));
        }
        
    }
    
    //Finds the closest tile to the enemy
    function GetCurrentTile()
    {
        var tiles = this.Space.FindAllObjectsByName("Floor");
        var currentDistance = -1337.0;
        
        //Scans through each tile and finds the closest one
        foreach (var ti in tiles)
        {
            var tempLocation = ti.Transform.WorldTranslation - this.Owner.Transform.WorldTranslation;
            var distance = Math.Pow(tempLocation.X, 2) + Math.Pow(tempLocation.Y, 2);
            
            if (!ti.NavigationPoint.FortyFiveCorner && (currentDistance < 0 || distance < currentDistance))
            {
                this.CurrentTile = ti;
                currentDistance = distance;
            }
        }
    }
}
